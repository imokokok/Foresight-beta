import { NextRequest } from "next/server";
import { ApiResponses, errorResponse, successResponse } from "@/lib/apiResponse";
import { ApiErrorCode } from "@/types/api";
import { supabaseAdmin } from "@/lib/supabase.server";
import { getSession } from "@/lib/session";

const SQL_CREATE_AUTH_TABLES = `
CREATE TABLE IF NOT EXISTS public.user_sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  session_id TEXT NOT NULL UNIQUE,
  chain_id INT NULL,
  auth_method TEXT NULL,
  ip_prefix TEXT NULL,
  user_agent TEXT NULL,
  device_id TEXT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_seen_at TIMESTAMPTZ DEFAULT NOW(),
  revoked_at TIMESTAMPTZ NULL
);
CREATE INDEX IF NOT EXISTS user_sessions_wallet_address_idx ON public.user_sessions (wallet_address);
CREATE INDEX IF NOT EXISTS user_sessions_last_seen_at_idx ON public.user_sessions (last_seen_at DESC);
ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.user_devices (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  device_id TEXT NOT NULL,
  first_seen_at TIMESTAMPTZ DEFAULT NOW(),
  last_seen_at TIMESTAMPTZ DEFAULT NOW(),
  verified_at TIMESTAMPTZ NULL,
  last_ip_prefix TEXT NULL,
  last_user_agent TEXT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(wallet_address, device_id)
);
CREATE INDEX IF NOT EXISTS user_devices_wallet_address_idx ON public.user_devices (wallet_address);
CREATE INDEX IF NOT EXISTS user_devices_last_seen_at_idx ON public.user_devices (last_seen_at DESC);
ALTER TABLE public.user_devices ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.login_audit_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  method TEXT NOT NULL,
  ip_prefix TEXT NULL,
  user_agent TEXT NULL,
  device_id TEXT NULL,
  risk_score INT NULL,
  risk_reason TEXT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS login_audit_events_wallet_address_idx ON public.login_audit_events (wallet_address);
CREATE INDEX IF NOT EXISTS login_audit_events_created_at_idx ON public.login_audit_events (created_at DESC);
ALTER TABLE public.login_audit_events ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.user_sessions ADD COLUMN IF NOT EXISTS device_id TEXT NULL;
ALTER TABLE public.login_audit_events ADD COLUMN IF NOT EXISTS device_id TEXT NULL;
ALTER TABLE public.login_audit_events ADD COLUMN IF NOT EXISTS risk_score INT NULL;
ALTER TABLE public.login_audit_events ADD COLUMN IF NOT EXISTS risk_reason TEXT NULL;
`;

function isMissingRelation(err: unknown) {
  const msg = String((err as any)?.message || "").toLowerCase();
  return msg.includes("relation") && msg.includes("does not exist");
}

export async function GET(req: NextRequest) {
  try {
    const session = await getSession(req);
    const address =
      typeof session?.address === "string" ? String(session.address).toLowerCase() : "";
    const currentSessionId =
      typeof (session as any)?.sid === "string" ? String((session as any).sid) : "";
    if (!/^0x[a-f0-9]{40}$/.test(address)) return ApiResponses.unauthorized("Not authenticated");
    if (!currentSessionId) {
      return errorResponse("请重新登录以启用登录记录", ApiErrorCode.INVALID_PARAMETERS, 400);
    }
    if (!supabaseAdmin) return ApiResponses.internalError("Missing service key");

    const { data, error } = await (supabaseAdmin as any)
      .from("login_audit_events")
      .select("id,created_at,method,ip_prefix,user_agent,device_id,risk_score,risk_reason")
      .eq("wallet_address", address)
      .order("created_at", { ascending: false })
      .limit(20);

    if (error) {
      if (isMissingRelation(error)) {
        return errorResponse(
          "缺少 user_sessions/login_audit_events 表",
          ApiErrorCode.DATABASE_ERROR,
          500,
          {
            setupRequired: true,
            sql: SQL_CREATE_AUTH_TABLES,
          }
        );
      }
      return ApiResponses.databaseError("Failed to load audit", error.message);
    }

    const events = Array.isArray(data)
      ? data.map((r: any) => ({
          id: r?.id ?? null,
          createdAt: String(r?.created_at || ""),
          method: String(r?.method || ""),
          ipPrefix: r?.ip_prefix ? String(r.ip_prefix) : null,
          userAgent: r?.user_agent ? String(r.user_agent) : null,
          deviceId: r?.device_id ? String(r.device_id) : null,
          riskScore: typeof r?.risk_score === "number" ? Number(r.risk_score) : null,
          riskReason: r?.risk_reason ? String(r.risk_reason) : null,
        }))
      : [];

    return successResponse({ events });
  } catch (e: any) {
    return ApiResponses.internalError("Failed to load audit", String(e?.message || e));
  }
}
