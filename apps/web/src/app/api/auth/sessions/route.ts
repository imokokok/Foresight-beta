import { NextRequest, NextResponse } from "next/server";
import { ApiResponses, errorResponse, successResponse } from "@/lib/apiResponse";
import { ApiErrorCode } from "@/types/api";
import { supabaseAdmin } from "@/lib/supabase.server";
import { getSession, clearSession } from "@/lib/session";
import { parseRequestBody } from "@/lib/serverUtils";
import { checkRateLimit, RateLimits } from "@/lib/rateLimit";

export const dynamic = "force-dynamic";
export const revalidate = 0;

function withNoStore<T>(res: NextResponse<T>) {
  try {
    res.headers.set("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate");
    res.headers.set("Pragma", "no-cache");
    res.headers.set("Expires", "0");
  } catch {}
  return res;
}

const SQL_CREATE_AUTH_TABLES = `
CREATE TABLE IF NOT EXISTS public.user_sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  session_id TEXT NOT NULL UNIQUE,
  chain_id INT NULL,
  auth_method TEXT NULL,
  ip_prefix TEXT NULL,
  user_agent TEXT NULL,
  device_id TEXT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_seen_at TIMESTAMPTZ DEFAULT NOW(),
  revoked_at TIMESTAMPTZ NULL
);
CREATE INDEX IF NOT EXISTS user_sessions_wallet_address_idx ON public.user_sessions (wallet_address);
CREATE INDEX IF NOT EXISTS user_sessions_last_seen_at_idx ON public.user_sessions (last_seen_at DESC);
ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.user_devices (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  device_id TEXT NOT NULL,
  first_seen_at TIMESTAMPTZ DEFAULT NOW(),
  last_seen_at TIMESTAMPTZ DEFAULT NOW(),
  verified_at TIMESTAMPTZ NULL,
  last_ip_prefix TEXT NULL,
  last_user_agent TEXT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(wallet_address, device_id)
);
CREATE INDEX IF NOT EXISTS user_devices_wallet_address_idx ON public.user_devices (wallet_address);
CREATE INDEX IF NOT EXISTS user_devices_last_seen_at_idx ON public.user_devices (last_seen_at DESC);
ALTER TABLE public.user_devices ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.login_audit_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  method TEXT NOT NULL,
  ip_prefix TEXT NULL,
  user_agent TEXT NULL,
  device_id TEXT NULL,
  risk_score INT NULL,
  risk_reason TEXT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS login_audit_events_wallet_address_idx ON public.login_audit_events (wallet_address);
CREATE INDEX IF NOT EXISTS login_audit_events_created_at_idx ON public.login_audit_events (created_at DESC);
ALTER TABLE public.login_audit_events ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.user_sessions ADD COLUMN IF NOT EXISTS device_id TEXT NULL;
ALTER TABLE public.login_audit_events ADD COLUMN IF NOT EXISTS device_id TEXT NULL;
ALTER TABLE public.login_audit_events ADD COLUMN IF NOT EXISTS risk_score INT NULL;
ALTER TABLE public.login_audit_events ADD COLUMN IF NOT EXISTS risk_reason TEXT NULL;
`;

function isMissingRelation(err: unknown) {
  const msg = String((err as any)?.message || "").toLowerCase();
  return msg.includes("relation") && msg.includes("does not exist");
}

export async function GET(req: NextRequest) {
  try {
    const session = await getSession(req);
    const address =
      typeof session?.address === "string" ? String(session.address).toLowerCase() : "";
    const currentSessionId =
      typeof (session as any)?.sid === "string" ? String((session as any).sid) : "";
    if (!/^0x[a-f0-9]{40}$/.test(address))
      return withNoStore(ApiResponses.unauthorized("Not authenticated"));
    if (!currentSessionId) {
      return withNoStore(
        errorResponse("请重新登录以启用会话管理", ApiErrorCode.INVALID_PARAMETERS, 400)
      );
    }
    if (!supabaseAdmin) return withNoStore(ApiResponses.internalError("Missing service key"));

    const rlKey = `wallet:${address}:session_list`;
    const rl = await checkRateLimit(rlKey, RateLimits.relaxed, "session_list");
    if (!rl.success) {
      const waitSec = Math.max(1, Math.ceil((rl.resetAt - Date.now()) / 1000));
      return withNoStore(
        errorResponse(`请求过于频繁，请 ${waitSec} 秒后重试`, ApiErrorCode.RATE_LIMIT, 429)
      );
    }

    const { data, error } = await (supabaseAdmin as any)
      .from("user_sessions")
      .select(
        "session_id,created_at,last_seen_at,ip_prefix,user_agent,revoked_at,auth_method,chain_id,device_id"
      )
      .eq("wallet_address", address)
      .order("last_seen_at", { ascending: false })
      .limit(20);

    if (error) {
      if (isMissingRelation(error)) {
        return withNoStore(
          errorResponse("数据库配置错误，请联系管理员", ApiErrorCode.DATABASE_ERROR, 500, {
            setupRequired: true,
          })
        );
      }
      return withNoStore(ApiResponses.databaseError("Failed to load sessions", error.message));
    }

    const sessions = Array.isArray(data)
      ? data.map((r: any) => ({
          sessionId: String(r?.session_id || ""),
          createdAt: String(r?.created_at || ""),
          lastSeenAt: String(r?.last_seen_at || ""),
          ipPrefix: r?.ip_prefix ? String(r.ip_prefix) : null,
          userAgent: r?.user_agent ? String(r.user_agent) : null,
          revokedAt: r?.revoked_at ? String(r.revoked_at) : null,
          authMethod: r?.auth_method ? String(r.auth_method) : null,
          chainId: typeof r?.chain_id === "number" ? Number(r.chain_id) : null,
          deviceId: r?.device_id ? String(r.device_id) : null,
        }))
      : [];

    return withNoStore(successResponse({ sessions, currentSessionId }));
  } catch (e) {
    const error = e as Error;
    return withNoStore(ApiResponses.internalError("Failed to load sessions", error.message));
  }
}

export async function POST(req: NextRequest) {
  try {
    const session = await getSession(req);
    const address =
      typeof session?.address === "string" ? String(session.address).toLowerCase() : "";
    const currentSessionId =
      typeof (session as any)?.sid === "string" ? String((session as any).sid) : "";
    if (!/^0x[a-f0-9]{40}$/.test(address))
      return withNoStore(ApiResponses.unauthorized("Not authenticated"));
    if (!currentSessionId) {
      return withNoStore(
        errorResponse("请重新登录以启用会话管理", ApiErrorCode.INVALID_PARAMETERS, 400)
      );
    }
    if (!supabaseAdmin) return withNoStore(ApiResponses.internalError("Missing service key"));

    const rlKey = `wallet:${address}:session_manage`;
    const rl = await checkRateLimit(rlKey, RateLimits.strict, "session_manage");
    if (!rl.success) {
      const waitSec = Math.max(1, Math.ceil((rl.resetAt - Date.now()) / 1000));
      return withNoStore(
        errorResponse(`请求过于频繁，请 ${waitSec} 秒后重试`, ApiErrorCode.RATE_LIMIT, 429)
      );
    }

    const body = await parseRequestBody(req);
    const target = typeof body?.sessionId === "string" ? String(body.sessionId) : "";
    if (!target) return withNoStore(ApiResponses.invalidParameters("sessionId is required"));

    const nowIso = new Date().toISOString();
    const { error } = await (supabaseAdmin as any)
      .from("user_sessions")
      .update({ revoked_at: nowIso })
      .eq("wallet_address", address)
      .eq("session_id", target)
      .is("revoked_at", null);

    if (error) {
      if (isMissingRelation(error)) {
        return withNoStore(
          errorResponse(
            "缺少 user_sessions/login_audit_events 表",
            ApiErrorCode.DATABASE_ERROR,
            500,
            {
              setupRequired: true,
              sql: SQL_CREATE_AUTH_TABLES,
            }
          )
        );
      }
      return withNoStore(ApiResponses.databaseError("Failed to revoke session", error.message));
    }

    const res = withNoStore(successResponse({ ok: true }));
    if (target === currentSessionId) {
      clearSession(res, req);
    }
    return res;
  } catch (e) {
    const error = e as Error;
    return withNoStore(ApiResponses.internalError("Failed to revoke session", error.message));
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const session = await getSession(req);
    const address =
      typeof session?.address === "string" ? String(session.address).toLowerCase() : "";
    const currentSessionId =
      typeof (session as any)?.sid === "string" ? String((session as any).sid) : "";
    if (!/^0x[a-f0-9]{40}$/.test(address))
      return withNoStore(ApiResponses.unauthorized("Not authenticated"));
    if (!currentSessionId) {
      return withNoStore(
        errorResponse("请重新登录以启用会话管理", ApiErrorCode.INVALID_PARAMETERS, 400)
      );
    }
    if (!supabaseAdmin) return withNoStore(ApiResponses.internalError("Missing service key"));

    const rlKey = `wallet:${address}:session_manage`;
    const rl = await checkRateLimit(rlKey, RateLimits.strict, "session_manage");
    if (!rl.success) {
      const waitSec = Math.max(1, Math.ceil((rl.resetAt - Date.now()) / 1000));
      return withNoStore(
        errorResponse(`请求过于频繁，请 ${waitSec} 秒后重试`, ApiErrorCode.RATE_LIMIT, 429)
      );
    }

    const nowIso = new Date().toISOString();
    const { error } = await (supabaseAdmin as any)
      .from("user_sessions")
      .update({ revoked_at: nowIso })
      .eq("wallet_address", address)
      .is("revoked_at", null);

    if (error) {
      if (isMissingRelation(error)) {
        return withNoStore(
          errorResponse(
            "缺少 user_sessions/login_audit_events 表",
            ApiErrorCode.DATABASE_ERROR,
            500,
            {
              setupRequired: true,
              sql: SQL_CREATE_AUTH_TABLES,
            }
          )
        );
      }
      return withNoStore(ApiResponses.databaseError("Failed to revoke sessions", error.message));
    }

    const res = withNoStore(NextResponse.json({ success: true, data: { ok: true } }));
    clearSession(res, req);
    return res;
  } catch (e) {
    const error = e as Error;
    return withNoStore(ApiResponses.internalError("Failed to revoke sessions", error.message));
  }
}
